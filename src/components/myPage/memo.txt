
//
import React, { useState } from "react";
import { LoadingOutlined, PlusOutlined } from "@ant-design/icons";
import { message, Upload } from "antd";
import type { UploadChangeParam } from "antd/es/upload";
import type { RcFile, UploadFile, UploadProps } from "antd/es/upload/interface";

const PortfolioAddThumbnail = () => {
  const getBase64 = (img: RcFile, callback: (url: string) => void) => {
    const reader = new FileReader();
    reader.addEventListener("load", () => callback(reader.result as string));
    reader.readAsDataURL(img);
  };

  const beforeUpload = (file: RcFile) => {
    const isJpgOrPng = file.type === "image/jpeg" || file.type === "image/png";
    if (!isJpgOrPng) {
      message.error("You can only upload JPG/PNG file!");
    }
    const isLt2M = file.size / 1024 / 1024 < 2;
    if (!isLt2M) {
      message.error("Image must smaller than 2MB!");
    }
    return isJpgOrPng && isLt2M;
  };

  const [loading, setLoading] = useState(false);
  const [imageUrl, setImageUrl] = useState<string>();

  const handleChange: UploadProps["onChange"] = (
    info: UploadChangeParam<UploadFile>
  ) => {
    if (info.file.status === "uploading") {
      setLoading(true);
      return;
    }
    if (info.file.status === "done") {
      // Get this url from response in real world.
      getBase64(info.file.originFileObj as RcFile, (url) => {
        setLoading(false);
        setImageUrl(url);
      });
    }
  };

  const uploadButton = (
    <div>
      {loading ? <LoadingOutlined /> : <PlusOutlined />}
      <div style={{ marginTop: 8 }}>Upload</div>
    </div>
  );

  return (
    <>
      <Upload
        name="avatar"
        listType="picture-card"
        className="avatar-uploader"
        showUploadList={false}
        action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
        beforeUpload={beforeUpload}
        onChange={handleChange}
      >
        {imageUrl ? (
          <img src={imageUrl} alt="avatar" style={{ width: "100%" }} />
        ) : (
          uploadButton
        )}
      </Upload>
    </>
  );
};

export default PortfolioAddThumbnail;



/**
   * existingData = [
  {
    resumeExperience: [
      // 여기에 기존 경력 데이터가 배열로 들어갑니다.
      {
        pastWorkDuration: {
          pastWorkEndDate: "2023-01-31",
          pastWorkStartDate: "2022-01-01",
        },
        pastWorkPlace: "Company A",
        pastWorkPosition: "Developer",
      },
      {
        pastWorkDuration: {
          pastWorkEndDate: "2022-12-31",
          pastWorkStartDate: "2022-06-01",
        },
        pastWorkPlace: "Company B",
        pastWorkPosition: "Designer",
      },
    ],
  },
];
   */

  /**
   * newData = {
    pastWorkDuration: {
      pastWorkEndDate: "2023-12-31",
      pastWorkStartDate: "2023-06-01",
    },
    pastWorkPlace: "Company C",
    pastWorkPosition: "Project Manager",
  };
  */

  //////////////////////////////////////////////////


const PortfolioAddThumbnail = () => {
  // 상태관리
  const [isFormVisible, setIsFormVisible] = useState(false);
  const { userId } = useUserStore();

  // 경로
  const CDNURL =
    "https://iwbhucydhgtpozsnqeec.supabase.co/storage/v1/object/public/portfolioThumbnail";
  const thumbnailFolder = "thumbnail";
  // const PDFFolder = "PDF";
  // const linkFolder = "link";
  // const { setUserportfolioThumbnailSrc } = usePortfolioStore();

  const { data: images = [] } = useQuery(
    ["portfolioThumbnail", userId],
    () => getFreelancerPortfolioThumbnail(userId, thumbnailFolder),
    {
      enabled: !!userId,
    }
  );
  
  const queryClient = useQueryClient();
  const uploadMutation = useMutation(
    (file: File) =>
      uploadFreelancerPortfolioThumbnail(userId, file, thumbnailFolder),
    {
      onSuccess: () =>
        queryClient.invalidateQueries(["portfolioThumbnail", userId]),
    }
  );
  //
  const uploadImageHandler = async (e: any) => {
    const file = e.target.files && e.target.files[0];
    if (file) {
      uploadMutation.mutate(file);
    }
  };


  const portfolioThumbnailSrc =
    images.length > 0
      ? CDNURL + "/" + userId + "/" + thumbnailFolder + "/" + images[0].name
      : "";
  // console.log(portfolioThumbnailSrc);

  // const portfolioPDFSrc =
  //   images.length > 0
  //     ? CDNURL + "/" + userId + "/" + PDFFolder + "/" + images[0].name
  //     : "";

  // const portfolioLinkSrc =
  //   images.length > 0
  //     ? CDNURL + "/" + userId + "/" + linkFolder + "/" + images[0].name
  //     : "";

  // useEffect(() => {
  //   setUserportfolioThumbnailSrc(portfolioThumbnailSrc);
  // }, [portfolioThumbnailSrc, setUserportfolioThumbnailSrc]);

  // Event Handler
  const toggleFormVisibility = () => {
    setIsFormVisible(!isFormVisible);
  };

  return (
    <>
      <S.ThumbnailButton onClick={toggleFormVisibility}>
        +썸네일 첨부하기
      </S.ThumbnailButton>
      {isFormVisible && (
        <input
          type="file"
          accept="image/*"
          onChange={(e) => uploadImageHandler(e)}
        />
      )}
    </>
  );
};

export default PortfolioAddThumbnail;

export const S = {
  ThumbnailButton: styled.button`
    cursor: pointer;
    padding: 10px;
    background-color: #007bff;
    color: white;
    border-radius: 5px;
    text-align: center;
    &:hover {
      background-color: #0056b3;
    }
  `,
};

// 8/25
// 파일
  // 합쳐서 가져오기
  const { data: bothFilesData = [] } = useQuery(
    ["bothFiles", userId],
    async () => {
      // 썸네일
      const thumbnailResponse = await getPortfolioFiles({
        userId,
        fileType: "thumbnail",
        pfId,
      });
      // pdf
      const pdfResponse = await getPortfolioFiles({
        userId,
        fileType: "PDF",
        pfId,
      });
      // const response = [...thumbnailResponse, ...pdfResponse];
      return { thumbnailResponse, pdfResponse };
    },
    {
      enabled: !!userId,
    }
  );

  // 8/25
  const thumbnailSrcs = files?.map((file: any) => {
    if (file && file.metadata.mimetype === "image/jpeg") {
      return CDNURL + `/${userId}/${pfId}/thumbnail/${file.name}`;
    }
    return null;
  });
  console.log(thumbnailSrcs);

  // const PDFSrc =
  //   file && file.metadata.mimetype === "application/pdf"
  //     ? CDNURL + `/${userId}/${pfId}/pdf/${file.name}`
  //     : null;
  // console.log(PDFSrc);

  const viewThumbnails = (
    <>
      {thumbnailSrcs.map((thumbnailSrc: string, index: any) => (
        <img
          key={index}
          className="portfolioThumbnail"
          src={thumbnailSrcs}
          alt="img"
          width="120px"
          height="120px"
          style={{ marginLeft: "10px" }}
        />
      ))}
      {/* {PDFSrc && (
        <a href={PDFSrc} target="_blank" rel="noopener noreferrer">
          PDF 열기
        </a>
      )} */}
    </>
  );

  return <div>{viewThumbnails}</div>;


  // 8/25
  interface NewPortfolioInfo {
  title: string;
  desc: string;
}
export const uploadPortfolioWithInfo = async ({
  newPortfolioInfo,
  userId,
  files,
  fileType,
}: {
  newPortfolioInfo: NewPortfolioInfo;
  userId: string;
  files: File[];
  fileType: "thumbnail" | "pdf";
}) => {
  // 포트폴리오 정보 업로드
  const { data: portfolioData, error: portfolioError } = await supabase
    .from("portfolios")
    .insert({
      title: newPortfolioInfo.title,
      desc: newPortfolioInfo.desc,
      freelancerId: userId,
    })
    .select();

  if (portfolioError) {
    throw new Error("Error adding portfolio info");
  }

  // 파일 업로드
  const fileUploadPromises = files.map(async (file) => {
    const { data: fileData, error: fileError } = await supabase.storage
      .from("portfolios")
      .upload(`${userId}/${portfolioData[0].portfolioId}/${fileType}/${uuidv4()}`, file);

    if (fileError) {
      throw new Error("Error uploading file");
    }

    return fileData;
  });

  const uploadedFiles = await Promise.all(fileUploadPromises);

  return {
    portfolioData: portfolioData[0], // 업로드된 포트폴리오 정보
    uploadedFiles, // 업로드된 파일 정보 배열
  };
};

// 8/25
 const uploadHandler = async () => {
    // 업로드
    if (selectedThumbnailFile) {
      uploadThumbnailMutation.mutate({ file: selectedThumbnailFile });
      
    }
  };

  const uploadThumbnailMutation = useMutation(
    ({ file }: { file: File }) => uploadThumbnail({ userId, file,  }),
    {
      onSuccess: () =>
        queryClient.invalidateQueries(["PortfolioThumbnail", userId]),
    }
  );